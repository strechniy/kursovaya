kursovaya
=========
Введение

Комбинаторика – раздел математики, посвящённый решению задач выбора и расположения элементов некоторого, обычно конечного множества в соответствии с заданными правилами.
	Каждое такое правило определяет способ построения некоторой конструкции из элементов исходного множества, называемой комбинаторной конфигурацией. Поэтому можно сказать, что целью комбинаторного анализа является изучение комбинаторных конфигураций. Это изучение включает в себя вопросы существования комбинаторных конфигураций, алгоритмы их построения, оптимизацию таких алгоритмов, а также решение задач перечисления, в частности определение числа конфигураций данного класса. Простейшим примером комбинаторных конфигураций являются перестановки, сочетания и размещения.
	Большой вклад в систематическое развитие комбинаторных методов был сделан Г. Лейбницем (диссертация «Комбинаторное искусство»), Я. Бернулли (работа «Искусство предположений»), Л. Эйлером. Можно считать, что с появлением работ Я. Бернулли и  Г. Лейб-ница комбинаторные методы выделились в самостоятельную часть математики. В работах Л.Эйлера по разбиениям и композициям натуральных чисел на слагаемые было положено начало  одному из основных методов перечисления комбинаторных конфигураций – методу производящих функций.   
	Возвращение интереса к комбинаторному анализу относится к 50-м годам ХХ в. в связи с бурным развитием кибернетики и дискретной математики и широким использованием электронно-вычислительной техники. В этот период активизировался интерес к классическим комбинаторным задачам.
	Классические комбинаторные задачи – это задачи выбора и расположения элементов конечного множества, имеющие в качестве исходной некоторую формулировку развлекательного содержания типа головоломок.
	В 1859 г. У. Гамильтон придумал игру «Кругосветное путешествие», состоящую в отыскании такого пути, проходящего через все вершины (города, пункты назначения) графа, изображенного на рис. 1, чтобы посетить каждую вершину однократно и возвратиться в исходную. Пути, обладающие таким свойством, называются гамильтоновыми циклами.
	Задача о гамильтоновых циклах в графе получила различные обобщения. Одно из этих обобщений – задача коммивояжера, имеющая ряд применений в исследовании операций, в частности при решении некоторых транспортных проблем.

2. ОСНОВНАЯ ЧАСТЬ

В 1859 г. У. Гамильтон придумал игру «Кругосветное путешествие», состоящую в отыскании такого пути, проходящего через все вершины (города, пункты назначения) графа, чтобы посетить каждую вершину однократно и возвратиться в исходную. Пути, обладающие таким свойством, называются гамильтоновыми циклами.
Задача о гамильтоновых циклах в графе получила различные обобщения. Одно из этих обобщений - задача коммивояжера, имеющая ряд применений в исследовании операций, в частности при решении некоторых транспортных проблем.
Задача коммивояжёра актуально и по сей день т.к. люди ищут кратчайшие пути и затраты на эти кратчайшие пути.

     2.1.1. Постановка задачи

Определить длину (Q) кратчайшего маршрута (L) коммивояжера.
Расстояния (Qij) между шестью городами представлены в таблице 1.

Таблица 1 - Условие задачи
Город	1	2	3	4	5	6
1		6	4	12	14	22
2	6		3	8	7	20
3	4	3		10	11	18
4	12	8	10		9	16
5	14	7	11	9		10
6	22	20	18	16	10	

В ходе выполнения курсового проекта требуется написать программу, выполняющую решение аналогичных задач линейного программирования с помощью алгоритма Дейкстры.

    2.1.2. Алгоритм Дейкстры
Алгоритм Дейкстры (Dijkstra's algorithm) - алгоритм на графах, изобретённый нидерландским ученым Э. Дейкстрой в 1959 году. Находит кратчайшее расстояние от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса. Алгоритм широко применяется в программировании и технологиях, например, его использует протокол OSPF для устранения кольцевых маршрутов. Известен также под названием "Сначала Кратчайший Путь" (Shortest Path First).
Алгоритм Дейкстры решает задачу о кратчайших путях из одной вершины для взвешенного ориентированного графа G = (V, E) с исходной вершиной s, в котором веса всех рёбер неотрицательны ( (u, v) ? 0 для всех (u, v) E). В случае, когда ребра графа не равны, целесообразно использовать этот алгоритм.
Формулировка задачи. Имеется граф. Некоторая его вершина обозначена как вершина 1. Необходимо найти минимальные пути от вершины 1 до каждой из вершин графа. Минимальным путём будем называть путь с минимальной суммой цен вдоль пути. Ценой назовем неотрицательное число являющееся весом ребра.
Идея алгоритма. Идея основывается на следующем очевидном утверждении: Пусть построен минимальный путь из вершины а в вершину B. И пусть вершина B связана с некоторым количеством вершин i. Обозначим через Ci - цену пути из вершины B в вершину i. Выберем из Ci минимальную величину. Тогда минимальное продолжение пути из точки B пойдёт через выбранную величину.


    

2.1.3. Математическая модель

Построим математическую модель:
n - число городов.
Xi j , i, j=1..N - матрица затрат, где Ci j - затраты на переход из i-го города  в j-й.
Xi j - матрица переходов с компонентами:
Xi j = -1, если коммивояжер совершает переход из i-го города в j-й,
Xi j = 0, если не совершает перехода,
где i, j = 1..N и ij.
Критерий:

  ,	(1)

где Сij - матрица стоимости переходов,
Xij - матрица переходов, где xij=0, если переход совершен и xij=1 в противном случае
Ограничения:

 , i = 1..N	(2)
 , j = 1..N	(3)
Ui - Uj + N  Xi j  N-1, i, j = 1..N, i  j.	(4)
 , k= 1..N,t=k-1 (5)


Условие (2) означает, что коммивояжер из каждого города выезжает только один раз; условие (3) - въезжает в каждый город только один раз; условие (4) - обеспечивает замкнутость маршрута, содержащего N городов, и не содержащего замкнутых внутренних петель; условие (5) - принцип треугольника: ранее выбранный путь оказался длиннее предыдущего.

2.1.4 Разработка алгоритма

Задача коммивояжера является одной из знаменитых задач теории комбинаторики. Она была поставлена в 1934 году, и об неё, как об Великую теорему Ферма обламывали зубы лучшие математики. В своей области (оптимизации дискретных задач) задача коммивояжера служит своеобразным полигоном, на котором испытываются всё новые методы. В данном курсовом проекте реализуется задача коммивояжера методом алгоритма Дейкстры.
В 1959 г. Голландский математик Дейкстра предложил алгоритм, который решает задачу коммивояжёра для любой матрицы исходный данных: симметричной, несимметричный и смешанной (отсутствуют некоторые ребра графа).
Суть задачи состоит в том, чтобы найти кратчайший замкнутый путь обхода нескольких городов и вернуться обратно в исходный город, при этом выполняя две проверки:
	Длина найденного ребра графа должна быть меньше или равна симметричному ребру графа. В противном случае выбирается симметричное ребро треугольника: ранее выбранный путь оказался длиннее предыдущего.

¬¬2.1.5. Описание программы

Для начала вычислений необходимо ввести количество городов.
На рисунке 1 показан этап выбора количества городов.
программа задача коммивояжер тестирование
 
Рисунок 1 - Выбор количества городов

После ввода данных, необходимо нажать кнопку «Enter». После этого программа составит матрицу городов, после чего нам надо ввести с какого города будем стартовать, и заканчивать, и произведет расчет длины пути и порядок обхода городов. Когда программа завершит свой расчет, то в блоке ответа появятся данные конечного результата.

 
Рисунок 2 - Консоль программы после расчета данных
 
2.1.6. Тестирование программы

Определить длину (Q) кратчайшего маршрута (L) коммивояжера. Расстояния (QIJ) между шестью городами представлены в таблице 1.
Пройдем алгоритм вручную. 
Начинаем движение с первого города в нашей таблице (Рисунок 3).

Рисунок 3 - Первый шаг расчета
 

После этого, мы движемся во второй город, выбирая из доступных, с минимальным расстоянием (Рисунок 4). 

Рисунок 4 - Второй шаг расчета
 

Таким образом, проделываем следующие шаги до последнего города.
Условия примера представляют собой симметричную задачу.
После выполненного расчета мы видим, что ответ удовлетворяет условиям. Так же в программе проводилось несколько других тестирований, ответы были положительны. 
 
2.1.7. Анализ полученных результатов

После успешного тестирования программы, в качестве исходных данных использовались параметры, заданные в курсовом проектировании. Результаты расчета приведены в следующем рисунке 5:

 
Рисунок 5 - Основная форма программы после вывода конечных данных

Ответ: длина маршрута равна 52, порядок обхода городов:

→3→2→5→6→4→1

При выполнение ручных расчётов результаты получились положительными. 






2.2.1. Числа Фибоначчи (определение)
Последовательность Фибоначчи определяется следующим образом:
 
 
 
Несколько первых её членов:
 
 
        2.2.2. История и числа Фибоначчи в природе
Эти числа ввёл в 1202 г. Леонардо Фибоначчи (Leonardo Fibonacci) (также известный как Леонардо Пизанский (Leonardo Pisano)). Однако именно благодаря математику 19 века Люка (Lucas) название "числа Фибоначчи" стало общеупотребительным.
Впрочем, индийские математики упоминали числа этой последовательности ещё раньше: Гопала (Gopala) до 1135 г., Хемачандра (Hemachandra) — в 1150 г.
Числа Фибоначчи в природе 
Сам Фибоначчи упоминал эти числа в связи с такой задачей: "Человек посадил пару кроликов в загон, окруженный со всех сторон стеной. Сколько пар кроликов за год может произвести на свет эта пара, если известно, что каждый месяц, начиная со второго, каждая пара кроликов производит на свет одну пару?". Решением этой задачи и будут числа последовательности, называемой теперь в его честь. Впрочем, описанная Фибоначчи ситуация — больше игра разума, чем реальная природа.
Индийские математики Гопала и Хемачандра упоминали числа этой последовательности в связи с количеством ритмических рисунков, образующихся в результате чередования долгих и кратких слогов в стихах или сильных и слабых долей в музыке. Число таких рисунков, имеющих в целом  долей, равно  .
Числа Фибоначчи появляются и в работе Кеплера 1611 года, который размышлял о числах, встречающихся в природе (работа "О шестиугольных снежинках").
Интересен пример растения — тысячелистника, у которого число стеблей (а значит и цветков) всегда есть число Фибоначчи. Причина этого проста: будучи изначально с единственным стеблем, этот стебель затем делится на два, затем от главного стебля ответвляется ещё один, затем первые два стебля снова разветвляются, затем все стебли, кроме двух последних, разветвляются, и так далее. Таким образом, каждый стебель после своего появления "пропускает" одно разветвление, а затем начинает делиться на каждом уровне разветвлений, что и даёт в результате числа Фибоначчи.
Вообще говоря, у многих цветов (например, лилий) число лепестков является тем или иным числом Фибоначчи.
Также в ботанике известно явление ''филлотаксиса''. В качестве примера можно привести расположение семечек подсолнуха: если посмотреть сверху на их расположение, то можно увидеть одновременно две серии спиралей (как бы наложенных друг на друга): одни закручены по часовой стрелке, другие — против. Оказывается, что число этих спиралей примерно совпадает с двумя последовательными числами Фибоначчи: 34 и 55 или 89 и 144. Аналогичные факты верны и для некоторых других цветов, а также для сосновых шишек, брокколи, ананасов, и т.д.
Для многих растений (по некоторым данным, для 90% из них) верен и такой интересный факт. Рассмотрим какой-нибудь лист, и будем спускаться от него вниз до тех пор, пока не достигнем листа, расположенного на стебле точно так же (т.е. направленного точно в ту же сторону). Попутно будем считать все листья, попадавшиеся нам (т.е. расположенные по высоте между стартовым листом и конечным), но расположенными по-другому. Нумеруя их, мы будем постепенно совершать витки вокруг стебля (поскольку листья расположены на стебле по спирали). В зависимости от того, совершать витки по часовой стрелке или против, будет получаться разное число витков. Но оказывается, что число витков, совершённых нами по часовой стрелке, число витков, совершённых против часовой стрелки, и число встреченных листьев образуют 3 последовательных числа Фибоначчи.
Впрочем, следует отметить, что есть и растения, для которых приведённые выше подсчёты дадут числа из совсем других последовательностей, поэтому нельзя сказать, что явление филлотаксиса является законом, — это скорее занимательная тенденция.

     2.2.3.  Свойства
Числа Фибоначчи обладают множеством интересных математических свойств.
Вот лишь некоторые из них:
•	Соотношение Кассини: 
 
•	Правило "сложения": 
 
•	Из предыдущего равенства при  вытекает: 
 
•	Из предыдущего равенста по индукции можно получить, что 
 всегда кратно  .
•	Верно и обратное к предыдущему утверждение:
если  кратно  , то  кратно  .
•	НОД-равенство: 
 
•	По отношению к алгоритму Евклида числа Фибоначчи обладают тем замечательным свойством, что они являются наихудшими входными данными для этого алгоритма
2.2.4  Фибоначчиева система счисления
Теорема Цекендорфа утверждает, что любое натуральное число  можно представить единственным образом в виде суммы чисел Фибоначчи:
 
где  ,  ,  ,  (т.е. в записи нельзя использовать два соседних числа Фибоначчи).
Отсюда следует, что любое число можно однозначно записать в фибоначчиевой системе счисления, например:
 
 
 
причём ни в каком числе не могут идти две единицы подряд.
Нетрудно получить и правило прибавления единицы к числу в фибоначчиевой системе счисления: если младшая цифра равна 0, то её заменяем на 1, а если равна 1 (т.е. в конце стоит 01), то 01 заменяем на 10. Затем "исправляем" запись, последовательно исправляя везде 011 на 100. В результате за линейное время будет получена запись нового числа.
Перевод числа в фибоначчиеву систему счисления осуществляется простым "жадным" алгоритмом: просто перебираем числа Фибоначчи от больших к меньшим и, если некоторое  , то  входит в запись числа  , и мы отнимаем  от  и продолжаем поиск.

          
3.	Заключение

В ходе выполнения курсового проекта были решены следующие задачи:
1)	Построена математическая модель;
2)	Описан алгоритм задачи;
3)	Разработан программный код на языке программирования C++;
4)	Решена поставленная задача с помощью разработанной программы;
5)	Проанализированы результаты;
Таким образом, можно считать, что цель курсового проекта достигнута.


4.	Список использованных источников
1.	Окулов С.М. Дискретная математика. Теория и практика решения задач по информатике: учебное пособие. – М.: БИНОМ. Лаборатория знаний, 2008. – 422 с. 
 2. Скиена С. Алгоритмы. Руководство по разработке. – 2-е изд.: пер. с англ. – СПб.: БХВ-Петербург, 2011. – 720 с.

 
5. Приложение 1

Код программы «Решение задачи коммивояжера с помощью алгоритма Дейкстры»

//
#include <vcl.h>
#include <tchar.h>
#include <stdio.h>
#include <conio.h>
//main()
{c2,c3,i,k,j,n,e,q,v,m,z,x,min,a,min2,h=0,c=0;("Koli4estvo gorodov : ");scanf("%i",&n); //ввод количество городов*t=new int[n];*t2=new int[n];**kg=new int*[n];(i=0;i<n;i++)[i]=new int[n];**kg1=new int*[n];(i=0;i<n;i++)[i]=new int[n];(i=0;i<n;i++)(j=0;j<n;j++)
kg[i][j]=0;(i=0;i<n;i++) //заполнение расстояние между городами
for(j=i+1;j<n;j++)
{("vedite racto9nnie %i do %i: ",i+1,j+1);("%i",&kg[i][j]);[i][j]=kg[i][j];
}();(" ");(i=0;i<n;i++)("%3i",i+1);("\n\n\n\n");
for(i=0;i<n;i++) // заполнение массива городов симметрично
{("%2i ",i+1);(j=0;j<n;j++)
{[j][i]=kg[i][j];[j][i]=kg[i][j];("%3i",kg[i][j]);
}("\n\n");
}("Vvedite na4al'nuy to4ky : ");scanf("%i",&k); //ввод с какого города гачгётся путь-;=k;x=k;=1;c2=0;=0;z=2;[0]=k;
do //поиск минимального пути между городами
{=99999;(j=x+1;j<n;j++)(min>=kg[x][j] && kg1[x][j]!=-1)
{
min=kg[x][j];
m=j;
}(j=0;j<x;j++)(min>kg[j][x] && kg1[j][x]!=-1)
{
min=kg[j][x];
m=j;
}[q]=x;[q]=m;(j=x+1;j<n;j++)[x][j]=-1;(j=0;j<x;j++)[j][x]=-1;=m;=0;(i=0;i<n && z!=1;i++)(j=i+1;j<n;j++)(kg1[i][j]==-1)
v=1;
{v=3;z=1;break;}++;
}(v!=1);[q]=x;t[q]=k;q++;v=q;z=0;q=0;c=0;c2=0;e=0;
do // проверка условий алгоритма Дейкстры
{
if(q!=0)
{ c=c+kg[t2[e]][t[q]];=c-kg[t2[e-1]][t[q-1]]-kg[t2[e]][t[q]]+kg[t[q]][t[q-1]]+kg[t2[e-1]][t[q]];}(c>c2 && q!=0 && z<q)
{=t2[e];[e]=t2[e-1];[e-1]=z;=t[q-1];[q-1]=t[q-2];[q-2]=z;=q;=-1;e=-1;c=0;c2=0;
}++;++;
}(v!=q);("\n\nput : %i",t[0]+1); //вывод пути(i=1;i<q;i++)("-%i",t[i]+1);("\n\n");("dlina puti : %i",c);//вывод длинны пути
getch();
}















6. Приложение 2
Код программы «Вычисление члена ряда (числа) Фибоначчи»
//
         #include "stdafx.h"
#include "iostream"
#include "iomanip"
#include "math.h"
#include "conio.h"
          using namespace plex;
          int n;
int ner(int n);
int rec(int n);
void main()
{   
   int m, r;
   cycle:{}
   cout<<"Vvedite znachenie n"<<endl<<"n=";
   cin>>n;
   cout<<"Viberite metod:"<<endl<<"1 - recursivnii"<<endl<<"2 - ne recursivnii"<<endl<<"Metod:";
   cin>>m;

   if (m==1)
   {
   r=rec(n);
   cout<<"Rezyl'tat: "<<r<<endl;   
   }
   else if (m==2)
   {
   r=ner(n);
   cout<<"Rezyl'tat: "<<r<<endl;   
   }
   else
   {
   cout<<"Viberite pravilnii metod!"<<endl;
   goto cycle;
   }
   goto cycle;
}

int ner(int n)
{
      int f=1;
   int fi=0;
   int se=1;
      for(int i=2;i<=n;i++)
      {
      f=fi+se;
   fi=se;
   se=f;
      }
      return f;
}

int rec(int n)
{
      if (n<=2)
   {
      return 1;
   }
   else
   {
   return rec(n-1)+rec(n-2);
   }
}


